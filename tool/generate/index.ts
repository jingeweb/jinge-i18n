import path from 'path';
import fs from 'fs';
import { execSync } from 'child_process';
import { TranslateDictDir, TranslateMetaDir, CWD } from '../util';
import { loadDict } from './dict';
import { SimpleHasher } from './hash';
import { handleHtml } from './html';
import { MetaStore } from './common';
import { handleJs } from './js';

const T_HEADER = `/** @eslint-disabled **/
/** this file is auto generated by jinge-i18n, don't modify it manually. **/
/** dictionary for original text: $TEXT$ **/;\n`;
const A_HEADER = `/** @eslint-disabled **/
/** this file is auto generated by jinge-i18n, don't modify it manually. **/
/** dictionary for original attributes:
$TEXT$
 **/
import { AComponent } from 'jinge-i18n';\n`;

export function generate() {
  const dict = loadDict();

  const meta: MetaStore = {
    defaultLocale: 'zh_cn',
    hasher: new SimpleHasher(),
    textRegisterMap: new Map(),
    attrRegisterMap: new Map(),
    outputJson: {
      dictionary: {},
      attribute: {},
    },
  };
  dict.files.forEach((file) => {
    const source = fs.readFileSync(path.resolve(CWD, file), 'utf-8');
    switch (path.extname(file)) {
      case '.html':
        handleHtml(source, file, dict, meta);
        break;
      case '.js':
        handleJs(source, file, dict, meta);
        break;
      default:
        break;
    }
  });

  execSync(`rm -rf ${TranslateDictDir} && mkdir -p ${TranslateDictDir}`);
  execSync(`rm -rf ${TranslateMetaDir} && mkdir -p ${TranslateMetaDir}`);
  meta.textRegisterMap.forEach((info, originalText) => {
    let code = T_HEADER.replace('$TEXT$', originalText);
    const imps: string[] = [];
    const d = meta.outputJson.dictionary[originalText];
    d?.compoents && imps.push('TComponent');
    d?.funcs && imps.push('t');
    meta.attrRegisterMap.get(d.hash)?.attrVList.length === 1 && imps.push('AComponent');
    if (imps.length > 0) {
      code += `import { ${imps.join(', ')} } from 'jinge-i18n';\n`;
    }
    fs.writeFileSync(path.join(TranslateDictDir, `${info.hash}.js`), code + info.outputCodes.join('\n'));
  });
  meta.attrRegisterMap.forEach((attrReg, attrHashes) => {
    if (attrReg.attrVList.length === 1) {
      fs.appendFileSync(path.join(TranslateDictDir, `${attrHashes}.js`), '\n' + attrReg.componentCodes.join('\n'));
      return;
    }
    const impCodes: string[] = [];
    const commentCodes: string[] = [];
    attrReg.attrVList.forEach((attrV) => {
      commentCodes.push(`  * ${attrV.text}`);
      impCodes.push(
        `import { ${Array.from(attrV.importSymbols)
          .map((s) => `${s} as ${s}_${attrV.hash}`)
          .join(', ')} } from './${attrV.hash}.js';\n`,
      );
    });
    fs.writeFileSync(
      path.join(TranslateDictDir, `${attrHashes}.js`),
      A_HEADER.replace('$TEXT$', commentCodes.join('\n')) + impCodes.join('') + attrReg.componentCodes.join('\n'),
    );
  });
  fs.writeFileSync(path.join(TranslateMetaDir, 'dictionary.json'), JSON.stringify(meta.outputJson.dictionary, null, 2));
  fs.writeFileSync(path.join(TranslateMetaDir, 'attribute.json'), JSON.stringify(meta.outputJson.attribute, null, 2));
}
